// Simple in-memory rate limiter for AI endpoints
// Runs before API routes to enforce rate limits

const rateLimitStore = new Map<string, { count: number; resetTime: number }>()

// Cleanup expired entries every 5 minutes
setInterval(() => {
  const now = Date.now()
  for (const [key, record] of rateLimitStore.entries()) {
    if (now > record.resetTime) {
      rateLimitStore.delete(key)
    }
  }
}, 5 * 60 * 1000)

export default defineEventHandler(async (event) => {
  // Only apply rate limiting to AI endpoints
  if (!event.node.req.url?.startsWith('/api/ai/')) {
    return
  }

  // Get client IP
  const forwarded = getHeader(event, 'x-forwarded-for')
  const ip = forwarded ? forwarded.split(',')[0].trim() : 
             getHeader(event, 'x-real-ip') || 
             event.node.req.socket?.remoteAddress || 
             'unknown'
  
  const key = `ai_rate_limit:${ip}`
  const now = Date.now()
  const maxRequests = 5
  const windowMs = 60 * 1000 // 1 minute
  
  let record = rateLimitStore.get(key)
  
  if (!record || now > record.resetTime) {
    // Create new or reset expired record
    record = {
      count: 0,
      resetTime: now + windowMs
    }
    rateLimitStore.set(key, record)
  }
  
  record.count++
  
  // Set rate limit headers
  setHeader(event, 'X-RateLimit-Limit', maxRequests.toString())
  setHeader(event, 'X-RateLimit-Remaining', Math.max(0, maxRequests - record.count).toString())
  setHeader(event, 'X-RateLimit-Reset', new Date(record.resetTime).toISOString())
  
  if (record.count > maxRequests) {
    throw createError({
      statusCode: 429,
      statusMessage: 'Too Many Requests',
      data: {
        error: 'Rate limit exceeded for AI endpoints',
        limit: maxRequests,
        window: '60s',
        retryAfter: Math.ceil((record.resetTime - now) / 1000)
      }
    })
  }
})